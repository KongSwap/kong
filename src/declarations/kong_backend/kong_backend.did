type TxId = variant {
    BlockIndex : nat;
    TransactionId : text;
};

type ICTransferReply = record {
    chain : text;
    symbol : text;
    is_send : bool;
    amount : nat;
    canister_id : text;
    block_index : nat;
};
type TransferReply = variant {
    IC : ICTransferReply;
};
type TransferIdReply = record {
    transfer_id : nat64;
    transfer : TransferReply
};

type UserReply = record {
    user_id : nat32;
    principal_id : text;
    account_id : text;
    user_name : text;
    my_referral_code : text;
    referred_by : opt text;
    referred_by_expires_at : opt nat64;
    fee_level : nat8;
    fee_level_expires_at : opt nat64;
    campaign1_flags : vec bool;
};
type UserResult = variant { Ok : UserReply; Err : text };

type UserBalancesReply = variant {
	LP : BalancesReply;
};
type BalancesReply = record {
    name : text;
	symbol : text;
	balance : float64;
	usd_balance : float64;
    symbol_0 : text;
    amount_0 : float64;
    usd_amount_0 : float64;
    symbol_1 : text;
    amount_1 : float64;
    usd_amount_1 : float64;
	ts : nat64;
};
type UserBalancesResult = variant { Ok : vec UserBalancesReply; Err : text };

type MessagesReply = record {
    message_id : nat64;
    title : text;
    message : text;
    ts : nat64;
};
type MessagesResult = variant { Ok : vec MessagesReply; Err : text };

type TokenReply = variant {
	LP : LPTokenReply;
	IC : ICTokenReply;
};
type LPTokenReply = record {
	token_id : nat32;
    pool_symbol : text;
    name : text;
    chain : text;
	symbol : text;
    token : text;
    pool_id_of : nat32;
    address : text;
	decimals : nat8;
    fee : nat;
    total_supply : nat;
    on_kong : bool;
};
type ICTokenReply = record {
	token_id : nat32;
	pool_symbol : text;
    name : text;
    chain : text;
	symbol : text;
    token : text;
	canister_id : text;
	decimals : nat8;	
	fee : nat;
    icrc1 : bool;
    icrc2 : bool;
    icrc3 : bool;
    on_kong : bool;
};
type TokensResult = variant { Ok : vec TokenReply; Err : text };

type PoolsReply = record {
    pools : vec PoolReply;
    total_tvl : nat;
    total_24h_volume : nat;
    total_24h_lp_fee : nat;
    total_24h_num_swaps : nat;
};
type PoolReply = record {
    pool_id : nat32;
    name : text;
    symbol : text;
    balance : nat;
    chain_0 : text;
    symbol_0 : text;
    address_0 : text;
    balance_0 : nat;
    lp_fee_0 : nat;
    chain_1 : text;
    symbol_1 : text;
    address_1 : text;
    balance_1 : nat;
    lp_fee_1 : nat;
    price : float64;
    lp_fee_bps : nat8;
    rolling_24h_volume : nat;
    rolling_24h_lp_fee : nat;
    rolling_24h_num_swaps : nat;
    rolling_24h_apy : float64;
    lp_token_symbol : text;
    lp_token_supply : nat;
    total_volume : nat;
    total_lp_fee : nat;
    on_kong : bool;
};
type PoolsResult = variant { Ok : PoolsReply; Err : text };

type PoolExpectedBalance = record {
    pool_symbol : text;
    balance : nat;
    lp_fee : nat;
    kong_fee : nat;
};
type ExpectedBalance = record {
    balance : nat;
    pool_balances : vec PoolExpectedBalance;
    unclaimed_claims : nat;
};
type CheckPoolsReply = record {
    symbol : text;
    actual_balance : nat;
    expected_balance : ExpectedBalance;
    diff_balance : int;
};
type CheckPoolsResult = variant { Ok : vec CheckPoolsReply; Err : text };

type TxsReply = variant {
    AddPool : AddPoolReply;
    AddLiquidity : AddLiquidityReply;
    RemoveLiquidity : RemoveLiquidityReply;
    Swap : SwapReply;
};
type TxsResult = variant { Ok : vec TxsReply; Err : text };

type RequestRequest = variant {
    AddPool : AddPoolArgs;
    AddLiquidity : AddLiquidityArgs;
    RemoveLiquidity : RemoveLiquidityArgs;
    Swap : SwapArgs;
};

type RequestReply = variant {
    Pending;
    AddPool : AddPoolReply;
    AddLiquidity : AddLiquidityReply;
    RemoveLiquidity : RemoveLiquidityReply;
    Swap : SwapReply;
};

type RequestsReply = record {
    request_id : nat64;
    statuses : vec text;
    request : RequestRequest;
    reply : RequestReply;
    ts : nat64;
};
type RequestsResult = variant { Ok : vec RequestsReply; Err : text };

type TransfersResult = variant { Ok : vec TransferIdReply; Err : text };

type AddTokenArgs = record {
    token : text;
    on_kong : opt bool;
};
type AddTokenReply = variant {
    IC : ICTokenReply;
};
type AddTokenResult = variant { Ok : AddTokenReply; Err : text };

type AddPoolArgs = record {
    token_0 : text;
    amount_0 : nat;
    tx_id_0 : opt TxId;
    token_1 : text;
    amount_1 : nat;
    tx_id_1 : opt TxId;
    lp_fee_bps : opt nat8;
    on_kong : opt bool;
};
type AddPoolReply = record {
    tx_id : nat64;
    symbol : text;
    request_id : nat64;
    status : text;
    balance : nat;
    chain_0 : text;
    symbol_0 : text;
    amount_0 : nat;
    chain_1 : text;
    symbol_1 : text;
    amount_1 : nat;
    add_lp_token_amount : nat;
    lp_fee_bps : nat8;
    lp_token_symbol : text;
    lp_token_supply : nat;
    transfer_ids : vec TransferIdReply;
    claim_ids : vec nat64;
    on_kong : bool;
    ts : nat64;
};
type AddPoolResult = variant { Ok : AddPoolReply; Err : text };

type AddLiquidityAmountsReply = record {
    symbol : text;
    chain_0 : text;
    symbol_0 : text;
    address_0 : text;
    amount_0 : nat;
    fee_0 : nat;
    chain_1 : text;
    symbol_1 : text;
    address_1 : text;
    amount_1 : nat;
    fee_1 : nat;
    add_lp_token_amount : nat;
};
type AddLiquiditAmountsResult = variant { Ok : AddLiquidityAmountsReply; Err : text };

type AddLiquidityArgs = record {
    token_0 : text;
    amount_0 : nat;
    tx_id_0 : opt TxId;
    token_1 : text;
    amount_1 : nat;
    tx_id_1 : opt TxId;
};
type AddLiquidityReply = record {
    tx_id : nat64;
    symbol : text;
    request_id : nat64;
    status : text;
    chain_0 : text;
    symbol_0 : text;
    amount_0 : nat;
    chain_1 : text;
    symbol_1 : text;
    amount_1 : nat;
    add_lp_token_amount : nat;
    transfer_ids : vec TransferIdReply;
    claim_ids : vec nat64;
    ts : nat64;
};
type AddLiquidityResult = variant { Ok : AddLiquidityReply; Err : text };
type AddLiquidityAsyncResult = variant { Ok : nat64; Err : text };

type RemoveLiquidityAmountsReply = record {
    symbol : text;
    chain_0 : text;
    symbol_0 : text;
    address_0 : text;
    amount_0 : nat;
    lp_fee_0 : nat;
    chain_1 : text;
    symbol_1 : text;
    address_1 : text;
    amount_1 : nat;
    lp_fee_1 : nat;
    remove_lp_token_amount : nat;
};
type RemoveLiquidityAmountsResult = variant { Ok : RemoveLiquidityAmountsReply; Err : text };

type RemoveLiquidityArgs = record {
    token_0 : text;
    token_1 : text;
    remove_lp_token_amount : nat;
};
type RemoveLiquidityReply = record {
    tx_id : nat64;
    symbol : text;
    request_id : nat64;
    status : text;
    chain_0 : text;
    symbol_0 : text;
    amount_0 : nat;
    lp_fee_0 : nat;
    chain_1 : text;
    symbol_1 : text;
    amount_1 : nat;
    lp_fee_1 : nat;
    remove_lp_token_amount : nat;
    transfer_ids : vec TransferIdReply;
    claim_ids : vec nat64;
    ts : nat64;
};
type RemoveLiquidityResult = variant { Ok : RemoveLiquidityReply; Err : text };
type RemoveLiquidityAsyncResult = variant { Ok : nat64; Err : text };

type SwapAmountsTxReply = record {
    pool_symbol : text;
    pay_chain : text;
    pay_symbol : text;
    pay_address : text;
    pay_amount : nat;
    receive_chain : text;
    receive_symbol : text;
    receive_address : text;
    receive_amount : nat;
    price : float64;
    lp_fee : nat;
    gas_fee : nat;
};
type SwapAmountsReply = record {
    pay_chain : text;
    pay_symbol : text;
    pay_address : text;
    pay_amount : nat;
    receive_chain : text;
    receive_symbol : text;
    receive_address : text;
    receive_amount : nat;
    mid_price : float64;    
    price : float64;
    slippage : float64;
    txs : vec SwapAmountsTxReply;    
};
type SwapAmountsResult = variant { Ok : SwapAmountsReply; Err : text };

type SwapArgs = record {
    pay_token : text;
    pay_amount : nat;
    pay_tx_id : opt TxId;
    receive_token : text;
    receive_amount : opt nat;
    receive_address : opt text;
    max_slippage : opt float64;
    referred_by : opt text;
};
type SwapTxReply = record {
    pool_symbol : text;
    pay_chain : text;
    pay_symbol : text;
    pay_amount : nat;
    receive_chain : text;
    receive_symbol : text;
    receive_amount : nat;
    price : float64;
    lp_fee : nat;
    gas_fee : nat;
    ts : nat64;
};
type SwapReply = record {
    tx_id : nat64;
    request_id : nat64;
    status : text;
    pay_chain : text;
    pay_symbol : text;
    pay_amount : nat;
    receive_chain : text;
    receive_symbol : text;
    receive_amount : nat;
    mid_price : float64;
    price : float64;
    slippage : float64;
    txs : vec SwapTxReply;
    transfer_ids : vec TransferIdReply;
    claim_ids : vec nat64;
    ts : nat64;
};
type SwapResult = variant { Ok : SwapReply; Err : text };
type SwapAsyncResult = variant { Ok : nat64; Err : text };

type SendArgs = record {
    token : text;
    amount : nat;
    to_address : text;
};
type SendReply = record {
    tx_id : nat64;
    request_id : nat64;
    status : text;
    chain : text;
    symbol : text;
    amount : nat;
    to_address : text;
    ts : nat64;
};
type SendResult = variant { OK : SendReply; Err : text };

service : {
    // canister information
    icrc1_name : () -> (text) query;
    
    // tokens(wildcard) - returns all tokens or wildcard search
    tokens : (opt text) -> (TokensResult) query;
    // pools(wildcard) - returns all pools or wildcard search
    pools : (opt text) -> (PoolsResult) query;

    // user() - returns user information
    get_user : () -> (UserResult) query;
    // user_balances(lp_token_wildcard) - returns all user balances or specific LP token balances (current only supports balance of LP tokens)
    user_balances : (opt text) -> (UserBalancesResult) query;
    // messages(message_id) - returns specific message or all messages of the user
    messages : (opt nat64) -> (MessagesResult) query;
    // txs(my_txs) - returns transactions of the user or all transactions
    txs : (opt bool) -> (TxsResult) query;
    // requests(request_id) - returns specific request or all requests of the user
    requests : (opt nat64) -> (RequestsResult) query;

    // add a new liquidity pool
    add_pool : (AddPoolArgs) -> (AddPoolResult);

    // add_liquidity_amounts(token_0, amount_0, token_1)
    // token_0, token_1 - format Symbol, Chain.Symbol, CanisterId or Chain.CanisterId ie. ckBTC, IC.ckBTC, or IC.ryjl3-tyaaa-aaaaa-aaaba-cai
    // amount_0, amount_1 - Nat numbers with corresponding decimal precision as defined in ledger canister
    // - calculates the required amount_1 to add liquidity to pool
    // - results of add_liquidity_amounts() are then pass to add_liquidity() for execution
    add_liquidity_amounts : (text, nat, text) -> (AddLiquiditAmountsResult) query;
    // adds token_0 and token_1 to the liqudity pool in return for LP tokens
    // - add_liquidity() has 2 variations:
    //   1) 2 x icrc2_approve + icrc2_transfer_from - user must icrc2_approve the amount_0+gas of token_0, amount_1+gas of token_1 and then call add_liquidity() where the canister will then icrc2_transfer_from
    //   2) 2 x icrc1_transfer - user must icrc1_transfer the amount_0 of token_0, amount_1 of token_1 and then call add_liquidity() with the block index (tx_id_0 and tx_id_1)
    add_liquidity : (AddLiquidityArgs) -> (AddLiquidityResult);
    // asnychronous version of add_liquidity()
    // request_id will be returned by add_liquidity_async() and poll requests(request_id) to get updated status
    add_liquidity_async : (AddLiquidityArgs) -> (AddLiquidityAsyncResult);

    // remove_liquidity_amounts(token_0, token_1, remove_lp_token_amount)
    // calcalates the expected token_0 and token_1 to be received from redeeming remove_lp_token_amount of LP tokens to the pool
    remove_liquidity_amounts : (text, text, nat) -> (RemoveLiquidityAmountsResult) query;
    // redeems remove_lp_token_amount of LP tokens to the pool and receives token_0 and token_1 in return
    remove_liquidity : (RemoveLiquidityArgs) -> (RemoveLiquidityResult);
    // asnychronous version of remove_liquidity()
    // request_id will be returned by remove_liquidity_async() and poll requests(request_id) to get updated status
    remove_liquidity_async : (RemoveLiquidityArgs) -> (RemoveLiquidityAsyncResult);

    // swap_amounts(pay_token, pay_amount, receive_token)
    // pay_token, receive_token - format Symbol, Chain.Symbol, CanisterId or Chain.CanisterId ie. ckBTC, IC.ckBTC, or IC.ryjl3-tyaaa-aaaaa-aaaba-cai
    // pay_amount, receive_amount - Nat numbers with corresponding decimal precision as defined in ledger canister
    // - calculates the expected receive_amount and price of the swap
    // - results of swap_amounts() are then pass to swap() for execution
    swap_amounts : (text, nat, text) -> (SwapAmountsResult) query;

    // swap()
    // pay_token, receive_token - format Symbol, Chain.Symbol, CanisterId or Chain.CanisterId ie. ckBTC, IC.ckBTC, or IC.ryjl3-tyaaa-aaaaa-aaaba-cai
    // pay_amount, receive_amount - Nat numbers with corresponding decimal precision as defined in ledger canister
    // - swaps pay_amount of pay_token into receive_amount of receive_token
    // - swap() has 2 variations:
    //   1) icrc2_approve + icrc2_transfer_from - user must icrc2_approve the pay_amount+gas of pay_token and then call swap() where the canister will then icrc2_transfer_from
    //   2) icrc1_transfer - user must icrc1_transfer the pay_amount of pay_token and then call swap() with the block index
    swap : (SwapArgs) -> (SwapResult);
    // asnychronous version of swap()
    // request_id will be returned by swap_async() and poll requests(request_id) to get updated status
    swap_async : (SwapArgs) -> (SwapAsyncResult);

    // send LP tokens to another user
    send : (SendArgs) -> (SendResult);

    add_token : (AddTokenArgs) -> (AddTokenResult);
    check_pools : () -> (CheckPoolsResult);
    get_requests : (opt nat64, opt nat32) -> (RequestsResult) query;
    get_txs : (opt nat64, opt nat32) -> (TxsResult) query;
    get_transfers : (opt nat64) -> (TransfersResult) query;
}
